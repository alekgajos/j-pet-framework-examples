/**
 *  @copyright Copyright 2016 The J-PET Framework Authors. All rights reserved.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may find a copy of the License in the LICENCE file.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  @file SignalFinder.cpp
 */

using namespace std;

#include <map>
#include <string>
#include <vector>
#include "../LargeBarrelAnalysis/SignalFinderTools.h"
#include "SignalsAndHits.h"
#include "JPetHit/JPetHit.h"
#include <JPetAnalysisTools/JPetAnalysisTools.h>
#include <JPetOptionsTools/JPetOptionsTools.h>

using namespace jpet_options_tools;

SignalsAndHits::SignalsAndHits(const char* name)
        : JPetUserTask(name)
{
        fSaveControlHistos = true;
}

SignalsAndHits::~SignalsAndHits() {}

//SignalsAndHits init method
bool SignalsAndHits::init()
{
        INFO("Started the combined module for signals and hits creation.");

        fOutputEvents = new JPetTimeWindow("JPetHit");

        /*************************************************************************/
        /* Signals-related init                                                  */
        /*************************************************************************/
	if (isOptionSet(fParams.getOptions(), fEdgeMaxTimeParamKey)) {
	  kSigChEdgeMaxTime = getOptionAsFloat(fParams.getOptions(), fEdgeMaxTimeParamKey);
	}else{
	  WARNING(Form("No value of the %s parameter provided by the user. Using default valu of %lf.", fEdgeMaxTimeParamKey.c_str(), kSigChEdgeMaxTime));
	}

	if (isOptionSet(fParams.getOptions(), fLeadTrailMaxTimeParamKey)) {
	  kSigChLeadTrailMaxTime = getOptionAsFloat(fParams.getOptions(), fLeadTrailMaxTimeParamKey);
	}else{
	  WARNING(Form("No value of the %s parameter provided by the user. Using default valu of %lf.", fLeadTrailMaxTimeParamKey.c_str(), kSigChLeadTrailMaxTime));
	}

        if (fSaveControlHistos) {
                getStatistics().createHistogram(
                        new TH1F("remainig_leading_sig_ch_per_thr",
                                "Remainig Leading Signal Channels",
                                4, 0.5, 4.5));
                getStatistics().createHistogram(
                        new TH1F("remainig_trailing_sig_ch_per_thr",
                                "Remainig Trailing Signal Channels",
                                4, 0.5, 4.5));
        }

        /*************************************************************************/
        /* Hits-related init                                                     */
        /*************************************************************************/
        INFO("Reading velocities.");

	if (isOptionSet(fParams.getOptions(), fVelocityCalibFileParamKey)) {
	  fVelocityCalibrationFilePath = getOptionAsString(fParams.getOptions(), fVelocityCalibFileParamKey);
	}else{
	  WARNING("No velocity calibration file provided!");
	}

	fVelocityMap = readVelocityFile();
	
        getStatistics().createHistogram(
                                        new TH1F("hits_per_time_window",
                                                 "Number of Hits in Time Window",
                                                 101, -0.5, 100.5
                                                 )
                                        );

        getStatistics().createHistogram(
                                        new TH2F("time_diff_per_scin",
                                                 "Signals Time Difference per Scintillator ID",
                                                 200, -20000.0, 20000.0,
                                                 192, 0.5, 192.5
                                                 )
                                        );

        getStatistics().createHistogram(
                                        new TH2F("hit_pos_per_scin",
                                                 "Hit Position per Scintillator ID",
                                                 200, -40.0, 40.0,
                                                 192, 0.5, 192.5
                                                 )
                                        );

	if (isOptionSet(fParams.getOptions(), fTimeWindowWidthParamKey)) {
	  kTimeWindowWidth = getOptionAsFloat(fParams.getOptions(), fTimeWindowWidthParamKey);
	}

	/*************************************************************************/
	/* Init for TOT plotter                                          	 */
	/*************************************************************************/
	for(int i=1; i <= getParamBank().getBarrelSlotsSize(); ++i){

	  getStatistics().createHistogram(
					  new TH1F(Form("tot_strip_%d", getParamBank().getBarrelSlot(i).getID()), "TOT uncalibrated; TOT [ns]; counts", 1000., 0., 100.)
					  );
	  
	  getStatistics().createHistogram(
					  new TH1F(Form("edep_strip_%d", getParamBank().getBarrelSlot(i).getID()), "TOT uncalibrated; TOT [ns]; counts", 1000., 0., 1500.)
					  );
	}

	
	
        return true;
}

//SignalsAndHits execution method
bool SignalsAndHits::exec()
{
  //getting the data from event in apropriate format
  if(auto timeWindow = dynamic_cast<const JPetTimeWindow* const>(fEvent)) {
    
    //mapping method invocation
    map<int, vector<JPetSigCh>> sigChsPMMap = SignalFinderTools::getSigChsPMMapById(timeWindow);
    
    //building signals method invocation
    vector<JPetRawSignal> allSignals = SignalFinderTools::buildAllSignals(
                                                                          sigChsPMMap,
                                                                          kNumOfThresholds ,
                                                                          getStatistics(),
                                                                          fSaveControlHistos,
                                                                          kSigChEdgeMaxTime,
                                                                          kSigChLeadTrailMaxTime);

    // transform the signals and push into the signals map
    for (auto & sig : allSignals) {
      fillSignalsMap(createPhysSignal(sig));      
    }

    vector<JPetHit> hits = HitTools.createHits(getStatistics(),
					       fAllSignalsInTimeWindow,
					       kTimeWindowWidth,
					       fVelocityMap);

    getStatistics().getHisto1D("hits_per_time_window")->Fill(hits.size());
    fAllSignalsInTimeWindow.clear();

    // save the hits already in the time order
    for (auto & hit : JPetAnalysisTools::getHitsOrderedByTime(hits)) {

      // only consider hits with at least 2 fired thresholds for the TOT histograms
      if( hit.getSignalA().getQualityOfPhe() < 0.5 || hit.getSignalB().getQualityOfPhe() < 0.5 ){
	//	continue;
      }
      
      
      // fill TOT plots
      double tot = (hit.getSignalA().getPhe() + hit.getSignalB().getPhe());
      double edep = exp((tot*1000.+1.1483e5) / 23144.);

      getStatistics().getHisto1D(Form("tot_strip_%d", hit.getBarrelSlot().getID()))->Fill(tot);
      getStatistics().getHisto1D(Form("edep_strip_%d", hit.getBarrelSlot().getID()))->Fill(edep);
      
      fOutputEvents->add<JPetHit>(hit);
    }
    
  }else{
    return false;
  }
  return true;
}

//SignalsAndHits finish method
bool SignalsAndHits::terminate()
{
  INFO("Combined creation of signals and hits done.");
  return true;
}


//saving method
void SignalsAndHits::saveRawSignals(const vector<JPetRawSignal>& sigChVec)
{
  for (auto & sigCh : sigChVec) {
    fOutputEvents->add<JPetRawSignal>(sigCh);
  }
}

JPetPhysSignal SignalsAndHits::createPhysSignal(const JPetRawSignal& rawSignal)
{
  JPetRecoSignal recoSignal;
  JPetPhysSignal physSignal;
  
  //reading threshold times by threshold number
  //from Leading and Trailing edge
  std::map<int,double> leadingPoints = rawSignal.getTimesVsThresholdNumber(JPetSigCh::Leading);
  std::map<int,double> trailingPoints = rawSignal.getTimesVsThresholdNumber(JPetSigCh::Trailing);

  //finding TOT for every threshold 1-4
  std::vector<double> tots;
  int threshold_counter = 0;
  double TOTsum = 0.;

  for(int i=1;i<5;i++){
    auto leadSearch = leadingPoints.find(i);
    auto trailSearch = trailingPoints.find(i);
    if (leadSearch != leadingPoints.end()
	&& trailSearch != trailingPoints.end()){
      tots.push_back(trailSearch->second - leadSearch->second);
      TOTsum += (trailSearch->second - leadSearch->second) / 1000.; // in ns
      threshold_counter++;
    }
  }
  
  if(tots.size()!=0){
    recoSignal.setCharge(tots.at(0));
    physSignal.setPhe(TOTsum);
    physSignal.setQualityOfPhe(threshold_counter/4.0);
  }else{
    recoSignal.setCharge(-1.0);
    physSignal.setPhe(0.);
    physSignal.setQualityOfPhe(0.);
  }
  
  //set the rest of Reco Signal properties to -1.0.
  recoSignal.setDelay(-1.0);
  recoSignal.setOffset(-1.0);
  recoSignal.setAmplitude(-1.0);
  
  //store the original Raw Signal in the RecoSignal as a processing history
  recoSignal.setRawSignal(rawSignal);
  physSignal.setRecoSignal(recoSignal);

  // Set time of Physical Signal as a time of Signal at First Threshold
  // This should be changed to more resonable
  std::map<int,double> leadingPointsMap = recoSignal
    .getRawSignal()
    .getTimesVsThresholdNumber(JPetSigCh::Leading);
  double time = leadingPointsMap.begin()->second;
  physSignal.setTime(time);
  physSignal.setQualityOfTime(0.0);
  
  return physSignal;
}

void SignalsAndHits::fillSignalsMap(const JPetPhysSignal & signal)
{
  auto scinId = signal.getPM().getScin().getID();
  if (signal.getPM().getSide() == JPetPM::SideA) {
    if (fAllSignalsInTimeWindow.find(scinId) != fAllSignalsInTimeWindow.end()) {
      fAllSignalsInTimeWindow.at(scinId).first.push_back(signal);
    } else {
      std::vector<JPetPhysSignal> sideA = {signal};
      std::vector<JPetPhysSignal> sideB;
      fAllSignalsInTimeWindow.insert(std::make_pair(scinId,
                                                    std::make_pair(sideA, sideB)));
    }
  } else {
    if (fAllSignalsInTimeWindow.find(scinId) != fAllSignalsInTimeWindow.end()) {
      fAllSignalsInTimeWindow.at(scinId).second.push_back(signal);
    } else {
      std::vector<JPetPhysSignal> sideA;
      std::vector<JPetPhysSignal> sideB = {signal};
      fAllSignalsInTimeWindow.insert(std::make_pair(scinId,
                                                    std::make_pair(sideA, sideB)));
    }
  }
}

HitFinderTools::VelocityMap SignalsAndHits::readVelocityFile(){

  HitFinderTools::VelocityMap velocitiesMap;
  std::ifstream input;
  input.open(fVelocityCalibrationFilePath);
  if (input.is_open())
    INFO("Velocity file " + fVelocityCalibrationFilePath + " opened correctly, reading data..");
  else {
    INFO("Error opening velocity file " + fVelocityCalibrationFilePath);
    return velocitiesMap;
  }

  int slot = 0;
  double vel = 0.0, error = 0.0;

  while (!input.eof()) {
    input >> slot >> vel >> error;
    velocitiesMap[slot] = std::make_pair(vel, error);
  }

  return velocitiesMap;
}
